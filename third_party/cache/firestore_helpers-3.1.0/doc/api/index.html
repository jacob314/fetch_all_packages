<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="generator" content="made with love by dartdoc 0.24.1">
  <meta name="description" content="firestore_helpers API docs, for the Dart programming language.">
  <title>firestore_helpers - Dart API docs</title>

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500,400i,400,300|Source+Sans+Pro:400,300,700" rel="stylesheet">
  <link rel="stylesheet" href="static-assets/github.css">
  <link rel="stylesheet" href="static-assets/styles.css">
  <link rel="icon" href="static-assets/favicon.png">

</head>

<body>

<div id="overlay-under-drawer"></div>

<header id="title">
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="https://github.com/fluttercommunity/firestore_helpers">firestore_helpers package</a></li>
  </ol>
  <div class="self-name">firestore_helpers</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<main>

  <div class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left">
    <h5><span class="package-name">firestore_helpers</span> <span class="package-kind">package</span></h5>
    <ol>
          <li class="section-title">Libraries</li>
          <li><a href="firestore_helpers/firestore_helpers-library.html">firestore_helpers</a></li>
    </ol>
  </div>

  <div class="col-xs-12 col-sm-9 col-md-8 main-content">
      <section class="desc markdown">
        <img src="https://img.shields.io/badge/Flutter%20Community-firestore__helpers-blue.svg?style=for-the-badge&amp;logo=data:image/png;base64,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" width="600">
<blockquote>
<p>DISCLAIMER:
As some users pointed out, FireStore does not correctly compare GeoPoints at this time which lead to more data might be returned from the server than the server-side query intended. As long as you always also use the client-side filtering too by providing a distanceAccessor you will get the right results but if you get a lot of data entries the performance will degrade. Google wants to change that in the Future but no ETA yet. <a href="https://github.com/firebase/firebase-js-sdk/issues/826#issuecomment-389598387">Please see</a></p></blockquote>
<blockquote>
<p>Warning: V3.0.0 has a breaking change as it fixes a typo clientSite &lt;-&gt; clientSide</p></blockquote>
<h1 id="firestorehelpers">FirestoreHelpers</h1>
<p>FireStore is a great database that is easy to work with. To make life even easier here is this package. It contains functions build queries dynamically and for location based queries.</p>
<p>The necessary math for the geographical calculations were ported from <a href="https://stackoverflow.com/questions/46630507/how-to-run-a-geo-nearby-query-with-firestore">this JS source on SO</a> by <a href="https://github.com/stparham">Stanton Parham</a></p>
<h2 id="creating-queries-dynamically">Creating Queries dynamically</h2>
<p>In case you want to modify your queries at runtime <code>builtQuery()</code> might be helpful:</p>
<pre class="language-Dart"><code class="language-Dart">/// 
/// Builds a query dynamically based on a list of [QueryConstraint] and orders the result based on a list of [OrderConstraint].
/// [collection] : the source collection for the new query
/// [constraints] : a list of constraints that should be applied to the [collection]. 
/// [orderBy] : a list of order constraints that should be applied to the [collection] after the filtering by [constraints] was done.
/// Important all limitation of FireStore apply for this method two on how you can query fields in collections and order them.
Query buildQuery({Query collection, List&lt;QueryConstraint&gt; constraints,
    List&lt;OrderConstraint&gt; orderBy})


/// Used by [buildQuery] to define a list of constraints. Important besides the [field] property not more than one of the others can ne [!=null].
/// They corespond to the possisble parameters of Firestore`s [where()] method. 
class QueryConstraint {
  QueryConstraint(
      {this.field,
      this.isEqualTo,
      this.isLessThan,
      this.isLessThanOrEqualTo,
      this.isGreaterThan,
      this.isGreaterThanOrEqualTo,
      this.isNull,
      this.arrayContains});
}

/// Used by [buildQuery] to define how the results should be ordered. The fields 
/// corespond to the possisble parameters of Firestore`s [oderby()] method. 
class OrderConstraint {
  OrderConstraint(this.field, this.descending);
}
</code></pre>
<h3 id="example">Example</h3>
<p>Lets assume we have an events collection in FireStore and we want to get all events that apply to certain constraints:</p>
<pre class="language-Dart"><code class="language-Dart">
// Let's assume that our Event class looks like this 

class Event{
  String id;
  String name;
  DateTime startTime;
  GeoPoint location;
}


Stream&lt;List&lt;Event&gt;&gt; getEvents({List&lt;QueryConstraint&gt; constraints}) {
  try {
    Query ref = buildQuery(
      collection: eventCollection, 
      constraints: constraints, orderBy: [
          new OrderConstraint("startTime", false),
        ]);
    return ref.snapshots().map((snapShot) =&gt; snapShot.documents.map(eventDoc) {
          var event = _eventSerializer.fromMap(eventDoc.data);
          event.id = eventDoc.documentID;
          return event;
        }).toList());
  } on Exception catch (ex) {
    print(ex);
  }
  return null;
}

/// And gets called somewhere else

 getEvents(constraints: [new QueryConstraint(field: "creatorId", isEqualTo: _currentUser.id)]);

</code></pre>
<p>To make this even more comfortable and powerful there is <code>getDataFromQuery()</code></p>
<pre class="language-Dart"><code class="language-Dart">typedef DocumentMapper&lt;T&gt; = T Function(DocumentSnapshot document);
typedef ItemFilter&lt;T&gt; = bool Function(T);
typedef ItemComparer&lt;T&gt; = int Function(T item1, T item2);

///
/// Convenience Method to access the data of a Query as a stream while applying 
/// a mapping function on each document with optional client side filtering and sorting
/// [qery] : the data source
/// [mapper] : mapping function that gets applied to every document in the query. 
/// Typically used to deserialize the Map returned from FireStore
/// [clientSideFilters] : optional list of filter functions that execute a `.where()` 
/// on the result on the client side
/// [orderComparer] : optional comparisson function. If provided your resulting data 
/// will be sorted based on it on the client

Stream&lt;List&lt;T&gt;&gt; getDataFromQuery&lt;T&gt;({
  Query query,
  DocumentMapper&lt;T&gt; mapper,
  List&lt;ItemFilter&gt; clientSidefilters,
  ItemComparer&lt;T&gt; orderComparer,
});
</code></pre>
<p>With this our example get this with some additional functionality:</p>
<p>We want the events to be ordered by name and only future events. 
In this example we don't do the sorting on the server but on client side after the filtering</p>
<pre class="language-Dart"><code class="language-Dart">Stream&lt;List&lt;Event&gt;&gt; getEvents({List&lt;QueryConstraint&gt; constraints}) {
  try {
    Query query = buildQuery(collection: eventCollection, constraints: constraints);
    return getDataFromQuery(
        query: query, 
        mapper: (eventDoc) {
          var event = _eventSerializer.fromMap(eventDoc.data);
          event.id = eventDoc.documentID;
          return event;
        }, 
        clientSidefilters: (event) =&gt; event.startTime &gt; DateTime.now()  // only future events
        orderComparer: (event1, event2) =&gt; event1.name.compareTo(event2.name) 
      );
  } on Exception catch (ex) {
    print(ex);
  }
  return null;
}
</code></pre>
<h2 id="location-based-queries">Location based queries</h2>
<blockquote>
<p>DISCLAIMER:
As some users pointed out, FireStore does not correctly compare GeoPoints at this time which lead to more data might be returned from the server than the server-side query intended. As long as you always also use the client-side filtering too by providing a distanceAccessor you will get the right results but if you get a lot of data entries the performance will degrade. Google wants to change that in the Future but no ETA yet. <a href="https://github.com/firebase/firebase-js-sdk/issues/826#issuecomment-389598387">Please see</a></p></blockquote>
<p>A quite common scenario in an mobile App is to query for data that's location entry matches a certain search area.
Unfortunately FireStore doesn't support real geographical queries, but we can query <em>less than</em> and <em>greater than</em> on <code>GeopPoints</code>. Which allows to span a search square defined by its south-west and north-east corners.</p>
<p>As most App require to define a search area by a centre point  and a radius we have <code>calculateBoundingBoxCoordinates</code></p>
<pre class="language-Dart"><code class="language-Dart">/// Defines the boundingbox for the query based
/// on its south-west and north-east corners
class GeoBoundingBox {
  final GeoPoint swCorner;
  final GeoPoint neCorner;

  GeoBoundingBox({this.swCorner, this.neCorner});
}

///
/// Defines the search area by a  circle [center] / [radiusInKilometers]
/// Based on the limitations of FireStore we can only search in rectangles
/// which means that from this definition a final search square is calculated
/// that contains the circle
class Area {
  final GeoPoint center;
  final double radiusInKilometers;

  Area(this.center, this.radiusInKilometers): 
  assert(geoPointValid(center)), assert(radiusInKilometers &gt;= 0);

  factory Area.inMeters(GeoPoint gp, int radiusInMeters) {
    return new Area(gp, radiusInMeters / 1000.0);
  }

  factory Area.inMiles(GeoPoint gp, int radiusMiles) {
    return new Area(gp, radiusMiles * 1.60934);
  }

  /// returns the distance in km of [point] to center
  double distanceToCenter(GeoPoint point) {
    return distanceInKilometers(center, point);
  }
}

///
///Calculates the SW and NE corners of a bounding box around a center point for a given radius;
/// [area] with the center given as .latitude and .longitude
/// and the radius of the box (in kilometers)
GeoBoundingBox boundingBoxCoordinates(Area area)
</code></pre>
<p>If you use <code>buildQuery()</code> is even gets easier with <code>getLocationsConstraint</code></p>
<pre class="language-Dart"><code class="language-Dart">/// Creates the necessary constraints to query for items in a FireStore collection that are inside a specific range from a center point
/// [fieldName] : the name of the field in FireStore where the location of the items is stored
/// [area] : Area within that the returned items should be
List&lt;QueryConstraint&gt; getLocationsConstraint(String fieldName, Area area) 
</code></pre>
<pre class="language-Dart"><code class="language-Dart">/// function type used to acces the field that contains the loaction inside 
/// the generic type
typedef LocationAccessor&lt;T&gt; = GeoPoint Function(T item);

/// function typse used to access the distance field that contains the 
/// distance to the target inside the generic type
typedef DistanceAccessor&lt;T&gt; = double Function(T item);

typedef DistanceMapper&lt;T&gt; = T Function(T item, double itemsDistance);
</code></pre>
<p><code>getDataInArea()</code> combines all the above functions to one extremely powerful function:</p>
<pre class="language-Dart"><code class="language-Dart">///
/// Provides as Stream of lists of data items of type [T] that have a location field in a
/// specified area sorted by the distance of to the areas center.
/// [area]  : The area that constraints the query
/// [source] : The source FireStore document collection
/// [mapper] : mapping function that gets applied to every document in the query.
/// Typically used to deserialize the Map returned from FireStore
/// [locationFieldInDb] : The name of the data field in your FireStore document.
/// Need to make the location based search on the server side
/// [locationAccessor] : As this is a generic function it cannot know where your
/// location is stored in you generic type.
/// optional if you don't use [distanceMapper] and don't want to sort by distance
/// Therefore pass a function that returns a valur from the location field inside
/// your generic type.
/// [distanceMapper] : optional mapper that gets the distance to the center of the
/// area passed to give you the chance to save this inside your item
/// if you use a [distanceMapper] you HAVE to pass [locationAccessor]
/// [clientSideFilters] : optional list of filter functions that execute a `.where()`
/// on the result on the client side
/// [distanceAccessor] : if you have stored the distance using a [distanceMapper] passing
/// this accessor function will prevent additional distance computing for sorting.
/// [sortDecending] : if the resulting list should be sorted descending by the distance
/// to the area's center. If you don't provide [loacationAccessor] or [distanceAccessor]
/// no sorting is done. This Sorting is done one the client side
/// [serverSideConstraints] : If you need some serverside filtering besides the [Area] pass a list of [QueryConstraint] 
/// [serverSideOrdering] : If you need some serverside ordering you can pass a List of [OrderConstraints]  
/// Using [serverSideConstraints] or  [serverSideOrdering] almost always requires to create an index for 
/// this field. Check your debug output for a message from FireStore with
/// a link to create them
Stream&lt;List&lt;T&gt;&gt; getDataInArea&lt;T&gt;(
    {@required Area area,
    @required Query source,
    @required DocumentMapper&lt;T&gt; mapper,
    @required String locationFieldNameInDB,
    LocationAccessor&lt;T&gt; locationAccessor,
    List&lt;ItemFilter&lt;T&gt;&gt; clientSidefilters,
    DistanceMapper&lt;T&gt; distanceMapper,
    DistanceAccessor&lt;T&gt; distanceAccessor,
    bool sortDecending = false,
    List&lt;QueryConstraint&gt; serverSideConstraints,
    List&lt;OrderConstraint&gt; serverSideOrdering})
</code></pre>
<p>Best to see an example how we would use it:</p>
<pre class="language-Dart"><code class="language-Dart">// We will define a wrapper class because we want our Event plut its distance back

class EventData{
  Event event;
  double distance;

  EventData(this.event, [this.distance]) 
}



Stream&lt;List&lt;EventData&gt;&gt; getEvents(area) {
  try {
    return getDataInArea(
        collection: Firestore.instance.collection("events"),
        area: area,
        locationFieldNameInDB: 'location',        
        mapper: (eventDoc) {
          var event = _eventSerializer.fromMap(eventDoc.data);
          // if you serializer does not pass types like GeoPoint through
          // you have to add that fields manually. If using `jaguar_serializer` 
          // add @pass attribute to the GeoPoint field and you can omit this. 
          event.location = eventDoc.data['location'] as GeoPoint;
          event.id = eventDoc.documentID;
          return new EventData(event);
        },
        locationAccessor: (eventData) =&gt; eventData.event.location,
        distanceMapper: (eventData, distance) {
          eventData.distance = distance;
          return eventData;
        },
        distanceAccessor: (eventData) =&gt; eventDatas.distance, 
        clientSidefilters: (event) =&gt; event.startTime &gt; DateTime.now()  // filer only future events
      );
  } on Exception catch (ex) {
    print(ex);
  }
  return null;
}
</code></pre>
<p><strong>IMPORTANT</strong> to enable FireStore to execute queries based on <code>GeopPoints</code> you can not serialize the GeoPoints before you hand them to FireStore's <code>setData</code> if you use a code generator that does not allow to mark certain field as passthrough you have to set the value manually like here. If using <code>jaguar_serializer</code>  add <code>@pass</code> attribute to the GeoPoint field and you can omit this.</p>
<pre class="language-Dart"><code class="language-Dart">  Future&lt;bool&gt; updateEvent(Event event) async {
    try {
      var eventData = _eventSerializer.toMap(event);
  -&gt;  eventData['location'] = event.location;
      await eventCollection.document(event.id).setData(eventData);
      return true;
    } catch (e, stack) {
      print(e);
      print(stack.toString());
      //todo logging
      return false;
    }
  }
</code></pre>
<p>I use <a href="https://pub.dartlang.org/flutter/packages?q=jaguar_serializer+">jaguar_serializer</a> which is great in combination with FireStore because it produces a <code>Map&lt;String, dynamic&gt;</code> instead of JSON string. To make not to encode GeoPoints but pass them through just add <code>@pass</code> attribute to your <code>GeoPoint</code> fields.</p>
      </section>
      
        <section class="summary">
            <h2>Libraries</h2>
          <dl>
            <dt id="firestore_helpers">
              <span class="name"><a href="firestore_helpers/firestore_helpers-library.html">firestore_helpers</a></span> 
            </dt>
            <dd>
              
            </dd>          </dl>
        </section>

  </div> <!-- /.main-content -->

</main>

<footer>
  <span class="no-break">
    firestore_helpers 3.1.0
  </span>

</footer>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="static-assets/typeahead.bundle.min.js"></script>
<script src="static-assets/highlight.pack.js"></script>
<script src="static-assets/URI.js"></script>
<script src="static-assets/script.js"></script>


</body>

</html>
