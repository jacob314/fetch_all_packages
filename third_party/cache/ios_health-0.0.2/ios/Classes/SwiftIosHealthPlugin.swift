import Flutter
import UIKit
import HealthKit

public class SwiftIosHealthPlugin: NSObject, FlutterPlugin {
  public static func register(with registrar: FlutterPluginRegistrar) {
    let channel = FlutterMethodChannel(name: "ios_health", binaryMessenger: registrar.messenger())
    let instance = SwiftIosHealthPlugin()
    registrar.addMethodCallDelegate(instance, channel: channel)
  }

  public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
     if call.method == "requestAuthorization"{
                HealthkitReader.sharedInstance.requestHealthAuthorization() { success in
                    result(success)
                }
            }
            if call.method == "getActivity"{
                self.getActivity(call, result: result)
            }

            if call.method == "getBasicHealthData" {
                self.getBasicHealthData(result: result)
            }
  }

   func getBasicHealthData(result: @escaping FlutterResult){
          let dob = HealthkitReader.sharedInstance.getDOB()
          let gender = HealthkitReader.sharedInstance.getBioLogicalSex()
          HealthkitReader.sharedInstance.getLastWeightReading(){
              (aWeight:Double?) in
              HealthkitReader.sharedInstance.getLastHeightReading(){
                  (aHeight:Double?) in
                  var dic = Dictionary<String,Any>()
                  if dob != nil {
                      dic["dob"] = dob!.description
                  }
                  if gender != nil {
                      dic["gender"] = gender!.asServerParam
                  }

                  if aWeight != nil {
                      dic["weight"] = aWeight!
                  }

                  if aHeight != nil {
                      dic["height"] = aHeight!
                  }
                  result(dic)
              }
          }
      }

      func getActivity(_ call: FlutterMethodCall, result: @escaping FlutterResult){
          guard let params = call.arguments as? Dictionary<String,String> else {
              result(nil)
              return
          }

          guard let metric = params["name"] else {
              result(nil)
              return
          }

          guard let units = params["units"] else {
              result(nil)
              return
          }
          guard let DateS = params["StartDate"] else {
              result(nil)
              return
          }

          guard let DateE = params["EndDate"] else {
              result(nil)
              return
          }

          var type: HKQuantityTypeIdentifier;
          switch metric {
          case "steps":
              type = HKQuantityTypeIdentifier.stepCount
          case "cycling":
              type = HKQuantityTypeIdentifier.distanceCycling
          case "walkRun":
              type = HKQuantityTypeIdentifier.distanceWalkingRunning
          case "flights":
              type = HKQuantityTypeIdentifier.flightsClimbed
          case "heartRate":
              type = HKQuantityTypeIdentifier.heartRate
          default:
              result(["errorCode": "4040", "error": "unsupported type"])
              return;
          }

          HealthkitReader.sharedInstance.requestHealthAuthorization() { success in
              HealthkitReader.sharedInstance.getHealthDataValueByRange(type: type, strUnitType: units,StartDate: DateS, EndDate: DateE) { results in
                  if let data = results {
                      var value: Double = 0
                      if data.count > 0
                      {
                          for result in data
                          {
                              value += Double(result["value"]as! String)!
                          }
                          let dic:Dictionary<String, Any> = ["name": metric, "value": value, "units": units]
                          result(dic)
                          return
                      }
                  }
                  result([])
              }
          }

      }





}


extension Date {
    var yesterday: Date {
        return Calendar.current.date(byAdding: .day, value: -3, to: startDay)!
    }

    var startDay: Date {
        return Calendar.current.date(bySettingHour: 0, minute: 0, second: 0, of: self)!
    }
}